- synchronized：jdk提供的可重入、非公平的同步阻塞原语，可以用来修饰方法和代码块。jvm会为每一个关联了synchronized的对象关联一个monitor监视器，当字节码执行器遇到monitorenter指令，或者调用方法时，方法的flags中包含ACC_SYNCHRONIZED，当前线程会先获取同步锁，然后在执行同步方法/代码块中的逻辑，如果获取失败，会在锁队列（entry_list）中等待。
	- 在jdk1.6，对synchronized进行了优化，提供了锁从偏向锁-轻量级锁-重量级锁的升级过程。
	- 首先线程A尝试获取锁，在mark word中设置当前线程id。当线程B获取锁时，如果线程A存活，并且占有着锁，将锁升级为轻量级锁，否则尝试cas设置mark word中的threadid指向自己，设置失败，也会将锁升级为轻量级锁。
	- B将锁升级为轻量级锁时，会等待安全点（没有字节码在执行），先暂停持有偏向锁的A线程，将锁升级为轻量级锁，标志位设置为00，并唤醒A线程，将mark word设置为指向栈中锁记录的指针，而mark word原本存有的hashCode和gc等信息会存放在栈中，此后B线程尝试自旋获取锁，如果获取超时或者在获取的过程中，有其它线程也在尝试获取锁，则会将锁升级为重量级锁，标志位设置为10。
	- 锁升级为重量级锁之后，获取锁失败的线程会并入ObjectMonitor监控器的entryList中阻塞，当持有锁的线程释放锁之后，entryList和waitset中被唤醒的线程都会竞争锁。
	- 锁粗化：将临近的同步代码块合并为一个，避免多次获取锁
	- 锁消除：JIT编译
	- 偏向锁用于几乎没有锁竞争的情况下，每次都是同一个线程获取锁。轻量级锁用于参与锁竞争的线程不多，并且同步逻辑执行快，其他线程可以通过自旋很快获取锁的情况下。



- hashmap：基于数组加链表实现，当链表长度达到阈值，会转换为红黑树，能够提高查找速度。
	- 如何解决hash冲突？拉链法，与hash表中冲突的元素组成链表。
	- hashmap如何扩容？首先，hashmap扩容的阈值是capacity * load factor。插入元素后判断，如果元素个数超过阈值，将触发扩容；或者将链表树化时，如果数组的长度小于64，也将扩容
		- 1.计算扩容后的容量，创建newtable，扩容一般是扩大二倍
		- 2.遍历之前的tab，通过hash & oldlength判断hash桶中的元素是在原来的index位置还是在index+oldlength的位置。
		- 3.关于TreeNode节点，扩容后如果hash桶中的元素个数小于6，则还原为链表。
- concurrenthashmap：基于hashmap，通过synchronized和cas保证线程安全性。
	- 如何扩容？和hashmap的条件一致
		- 1.计算每个线程处理的桶空间，默认为16
		- 2.将新表设置为oldtab的二倍
		- 3.计算当前线程此次要处理的下标范围
		- 4.如果桶内有数据，转移数据 （hash & oldlength计算要转移的位置）


- 如何用LinkedHashMap实现LRU？
	- 该集合维护了双向链表，可以记录插入顺序和访问顺序，每次访问某个元素的话，该元素会插入到链表的后方，当进行清理的时候，将链表首部的节点删除即可
- 如何用TreeMap实现一致性hash？
	-使用TreeMap存放虚拟节点，TreeMap<Long hash, Node 真实机器节点>，通过tailMap返回为空的话，返回map中的第一个虚拟节点。hash可以使用虚拟节点的名称计算，利用下述MurMurHash算法计算


- AOP：Spring的AOP依靠动态代理技术实现，为应用程序提供功能拓展、将固定模式的代码从业务中剥离出来单独维护。AOP为我们提供了在切入点的before/afterReturning/around/afterThrowable/after的增强。
	- AOP代理模式有两种，默认使用java动态代理（基于接口），cglib基于继承
	- AOP最常见的就是Spring事务模块提供的@Transactional注解为添加了该注解的方法提供事务的创建、提交、回滚的功能。
	- 常用的还有日志记录、性能监控等
- 动态代理和静态代理：对某个对象进行包装，以控制这个对象的访问（方法增强）。代理类需要和resource类有共同的父类接口。
	- 静态代理在编译的时候就确定了代理类。动态代理是在运行过程中生成代理类的。静态代理一般只能代理一个类，而动态代理可以代理多个实现了接口的类。

- jdk动态代理和cglib的区别：jdk动态代理只能代理实现了接口的类，通过反射机制生成实现该接口的类，通过调用被代理类的方法进行增强。而cglib是生成一个代理子类，覆盖其中的方法进行增强（因为采用了继承，所以该类和方法不要采用final修饰），底层使用asm进行字节码的生成。







- 线程的状态及变化过程
	- 线程的状态有初始、运行、阻塞、等待、超时等待、终止六种状态，其中运行可以细分为就绪和运行中
	- 线程实例化之后状态为初始；调用start()方法状态为运行；获取同步锁失败，进入阻塞状态；在阻塞状态被唤醒获取到锁，进入运行状态；运行中调用Thread.join()/Object.wait()/LockSupport.park()进入等待状态；在运行中调用Thread.sleep(long)/Object.wait(long)/Thread.join(long)/LockSupport.parkNanos()/LockSupport.parkUtil()进去超时等待状态；在等待/超时等待状态调用LockSupport.unpark()/Object.notify()/Object.notifyAll()进入运行状态；线程执行完成进去终止状态。
	
- JVM：类加载器、执行引擎、运行时区域、垃圾回收器、本地方法接口。
- 运行时区域包括：堆、虚拟机栈、本地方法栈、方法区（元空间）、程序计数器。
	- 程序中实例化的对象基本都是放到堆中
	- 虚拟机栈存储的是Java方法运行时数据
	- 方法区存储的是类元数据、静态变量、常量、编译后的代码
	- 程序计数器是线程私有，存储的是线程执行字节码的行号，用于线程恢复后能恢复正确执行的位置。


	
- AQS是一种提供了原子式状态管理、阻塞/唤醒线程以及队列模型的框架。



- volatile：可见性和一定程度的有序性
	- 对一个volatile的读，总是能看到任意线程对这个变量最后的写入
	- 确保指令重排序时，保证当程序执行到volatile变量的读/写时，在其前面的操作已经全部运行，在其后面的操作都没有运行。
	- volatile变量在汇编语言中，相对于没有volatile的变量多了lock的前缀，也叫内存屏障。
	- 重排序是虚拟机为了优化执行速度进行的优化，但是会保证优化后的程序与优化前的程序在单线程的环境下执行的结果一致。






- tcp和udp：tcp数据传输协议，面向连接，基于字节流的传输层协议，支持失败重传和有序。udp用户数据报协议，无需建立连接，发送数据报，不可靠，不保证有序。






- 三次握手：1.客户端向服务端发送SYN+序号A，2.服务端收到SYN后回复SYN（序号B）+ACK(A+1)，3.客户端向服务端发送ACK（B+1），服务端收到该ack之后，连接正式建立
- 四次挥手：
	- A关闭向B的发送通道：
		- A发送FIN码（序号K），并且发送一个ACK，对B最后一次发送数据的确认
		- B返回ACK（序号K+1）
	- B关闭向A的发送通道：（收到A关闭的请求后，不一定关闭B向A发送的通道）
		- B发送FIN码（序号X）
		- A向B发送ACK（序号X+1）
- 原因：三次握手完之后，服务端和客户端都需要知道对方的发送和接收功能是完好的，第一次服务端知道客户端可以发送消息，第二次客户端知道服务端可以接收和发送消息，第三次，服务端知道客户端可以接收消息。  
 	   四次挥手，因为tcp连接是全双工的，客户端和服务端都可以发送和接收消息。

-  Spring Cloud 和 Dubbo：spring cloud是一套微服务的解决方案，由一系列组件提供功能支持。而dubbo是一个分布式的服务治理框架。
	-  两者最大的区别在于服务调用方面，dubbo采用的是RPC的方式调用，提供了多种基于长连接的NIO框架的封装，以及Hessian2等序列化方式，服务调用的性能较Spring Cloud的Http Rest方式高，但是dubbo服务提供方和调用方接口依赖方式太强，项目大的话，服务间的依赖管理会很麻烦，而Http Rest不会出现这种问题，只需要将接口维护到类似swagger上面就可以。
	-  cloud生态圈的组件完善，dubbo只是为我们提供了服务治理，如果需要使用配置中心等组件，需要整合，毕竟不是和dubbo无缝连接的组件，整合的话风险高一些。
	-  dubbo在国内用户人群广，文档多，而cloud文档相对较少，而且开发项目需要引入的组件较多，学习成本高。


- dubbo原理：
	- 

- 容错模式（cluster）：失败重试、快速失败、失败记录、失败定时重试、forking（并行调用，只要有一个成功就算成功）、广播调用（一个失败就算失败）
- 负载：随机（默认）、轮询、最少活跃调用数、一致性哈希（带有相同参数的请求总是被发给同一个提供者）





- kafka原理
	- 经验证，顺序写磁盘效率比随机写内存还要高，这是Kafka高吞吐率的一个很重要的保证
	- 上面一节还涉及到一个概念，即HW。HW俗称高水位，HighWatermark的缩写，取一个partition对应的ISR中最小的LEO作为HW，consumer最多只能消费到HW所在的位置。另外每个replica都有HW,leader和follower各自负责更新自己的HW的状态。对于leader新写入的消息，consumer不能立刻消费，leader会等待该消息被所有ISR中的replicas同步后更新HW，此时消息才能被consumer消费。这样就保证了如果leader所在的broker失效，该消息仍然可以从新选举的leader中获取。对于来自内部broker的读取请求，没有HW的限制。
	- 数据可靠性和持久性保证 request.required.acks min.insync.replicas
	- HW
	- ISR宕机顺序影响恢复




- 栈的原理和应用：左右括号是否正确匹配的经典问题
	- 




- 双亲委派机制：双亲委派是一个规范，它规定除了顶层的启动类加载器，其它每个加载器都应该有自己的父类加载器。当进行类加载时，首先把加载请求委派给父加载器完成，只有当父类加载器反馈无法完成加载时，自己才会尝试加载。


- 分布式锁的作用：1.提升效率，用锁来避免一个任务被不必要的执行两次。2.正确性，保证任务按照正确的步骤执行，防止两个节点同时操作一份数据，造成文件冲突、数据丢失。

- 分布式锁实现：
	- 基于redis的实现。通过set(key, value, px , mill, nx)获取锁，value为唯一值，用于解锁操作。ex代表不存在该key时才能设置，px设置缓存存活时间，单位为毫秒。解锁的时候需要比较当前key的value值是否与之前设置的值相等，为了保证原子性，需要使用lua脚本。
	- 如果需要考虑获取锁之后，主节点还没来得及将数据同步到从节点就挂掉的情况，可以采用官方给的Redlock算法。
		- 1.获取本地时间
		- 2.客户端使用相同的key和value依次在每个master上尝试获取锁（如果获取锁的时间超过锁操作的快速失效时间，则直接返回）
		- 3.计算获取锁的消耗是否小于锁超时时间，并且成功获取锁的节点是否超过master节点数的一半，如果满足则获取锁成功
		- 4.获取锁成功，客户端持有锁的时间为锁超时时间-获取锁的消耗时间
		- 5.如果获取失败，则尝试在所有master节点释放锁



- 缓存一致性：
	- 起因，为了提高查询速度，将数据库中的部分数据放到缓存中。为了保证数据库中数据和缓存中数据一致。
	- 应该先更新数据库，再更新缓存。但是可能会出现更新缓存失败的情况，可以通过使用阿里的canal将mysql数据库的binglog进行收集，异步处理缓存数据。简单的可以设置失效时间，但是设置失效时间的话，要注意缓存雪崩的问题，失效时间不要都设置成一样的，可以在某个范围内随机。
	- 先更新缓存，后更新数据库存在的问题：A更新数据，B查询，如果A删除缓存之后，B查询cache miss，然后查询数据库更新缓存，此后A才更新数据库；A更新数据，B更新数据，因为更新数据库和更新缓存不是一个原子性操作，会出现A update redis -> B update redis -> B update db -> A update db

- redis淘汰策略：
	- 
- redis一致性hash：
	- 


- lru最近最少使用。lfu最近最不常使用

- 数据库设计：找主表-表关系（一对多）-垂直拆分-索引后加
	- 


- 索引：Innodb 聚族索引，B+ 树，数据放在叶子节点上。Myisam非聚族索引，数据存储在主键的索引树叶子节点。
	- 索引的设计原则


- mvcc：
	- 

- 事务隔离级别：
	- 

- spring事务传播行为：
	- 


- 系统设计：大-服务边界
	- 

- zookeeper如何保证一致性的？
	- 
- zookerper选举机制？
	- 









- Junit注解：beforeclass(首先执行，只执行一次)，afterclass（最后执行，只执行一次），before（每一个测试用例执行前执行），after（每一个测试用例执行后执行）




- ThreadLocal：线程本地变量，多个线程访问同一个threadlocal变量时，读取的值是不一样的。
	- 每个Thread中有一个ThreadLocalMap属性，以ThreadLocal为key（软引用），设置的值为value存储在线程中。
	- 适用场景：线程共享变量；变量在方法之间共享，但不希望被多线程共享

- 引用类型：强软弱虚

- spring注解如何生效、类是如何扫描的


- 分布式事务
	- 