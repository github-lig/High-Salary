除了不能继承一个enum之外，我们基本上可以将enum当成是一个常规的类。  
如果需要，我们可以在枚举类型中添加一些构造器、方法和域。   

---
一般来说，我们希望每个枚举常量都有自己的状态，为此，我们可以对枚举类添加域。

	
	public enum EnumBasic {
	    LOW("desc low"), MIDDLE("desc middle"), HIGH("desc high");
	
	    private String desc;
	
	    EnumBasic(String desc) {
	        this.desc = desc;
	    }
	
	    public static void main(String[] args) {
	        System.out.println(MIDDLE.desc); //desc middle
	    }
	}

---
enum通常被用于switch语句中
	
	public class EnumSwitch {
	    Signal signal = Signal.GREEN;
	
	    public void changeColor() {
	        switch (signal) {
	            case GREEN: signal = Signal.YELLOW;
	                        break;
	            case YELLOW: signal = Signal.RED;
	                        break;
	            case RED: signal = Signal.GREEN;
	                        break;
	        }
	    }
	
	    @Override
	    public String toString() {
	        return "The color is :" + signal;
	    }
	
	    public static void main(String[] args) {
	        EnumSwitch enumSwitch = new EnumSwitch();
	        for (int i = 0; i < 5; i ++) {
	            System.out.println(enumSwitch);
	            enumSwitch.changeColor();
	        }
	    }
	}
	
	enum Signal {GREEN, YELLOW, RED}
	
	运行结果：
		The color is :GREEN
		The color is :YELLOW
		The color is :RED
		The color is :GREEN
		The color is :YELLOW

---
在基本用法中我们已经看过values()方法，并且知道values方法是编译器帮我们添加的方法。当我们将枚举实例向上转型为Enum的对象时，那么values方法就不可访问了。此时我们可以通过Class类中的getEnumConstants()方法获取所有enum实例。
	
	public enum EnumBasic {
	    LOW, MIDDLE, HIGH;
	    public static void main(String[] args) {
	        Enum e = LOW;
	        Arrays.stream(e.getClass().getEnumConstants()).forEach(en -> System.out.println(en));
	    }
	}
	
	运行结果：
		LOW
		MIDDLE
		HIGH

---




用处：
单继承的原因，可以实现多个接口  
随机选取  
接口组织枚举  
EnumSet   
EnumMap   
添加抽象方法   
enum 职责链   
状态机   
多路分发   

