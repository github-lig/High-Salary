JVM和JMM-类初始化-对象的创建-句柄-对象的回收-对象大小计算  
JMM-虚拟机栈-栈帧-对象的内存位置-元空间-常量池-Integer（-128）~127-String

---
- **JVM**：Java Virtual Machine。运行Java程序必不可少的机制，实现了Java平台无关性的特性。我们编写的Java程序并不直接在CPU上执行，而是由JVM执行。JVM屏蔽了与具体平台相关的信息，使Java语言编译程序只需生成在JVM允许的字节码（.class）文件，就可以在多个平台上不加修改的运行。JVM在执行字节码时，把字节码解释成具体机器上的机器指令执行。JVM同时也是Java程序的安全检查引擎。  
	- Java虚拟接本质上是一个程序，当在命令行启动jvm的时候，它就开始执行保存在某个字节码文件中的指令。
	- JVM分为五大模块：类加载器、运行时数据区、执行引擎、本地方法接口、垃圾回收模块。
	- JVM不是真实的物理机，不存在寄存器，所以指令集是使用Java栈（先进后出）来存储中间数据的。
- **运行时数据区域**：
	- ***区域划分***：堆、虚拟机栈、本地方法栈、元空间、程序计数器。
	- ***程序计数器***：线程私有，唯一不会出现OutOfMemoryError的区域，当前线程所执行字节码的行号指示器。
		- 字节码解释器通过改变计数器的值来选取下一条要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成
		- 线程切换后能恢复正确执行的位置
	- ***虚拟机栈***：Java方法执行的内存模型。线程私有、生命周期和线程相同。会出现StackOverFlowError和OutOfMemoryError异常。
		- 每个方法在执行的时候都会创建一个栈帧压入栈中，一个栈帧包括局部变量表、动态链接、操作数栈、方法出口。每个方法从调用到完成对应着一个栈帧入栈到出栈。
			- 局部变量表：变量值存储空间，用于存放方法参数和方法内定义的局部变量。在Java程序编译为class文件时，就确定了该方法所需要分配的局部变量表的最大容量。
			- 动态连接：每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。持有这个引用是为了支持方法调用过程中的动态连接（将符号引用解析为直接引用）
			- 操作数栈（操作栈）：与字节码指令结合，用来进行运算。在编译时确定其最大深度。可以存放任意Java数据类型（Reference长度为32位），包括long和double。32位所占的容量为1，64位为2。
			- 方法出口：1.执行引擎遇到任意一个方法执行的字节码指令。2.遇到了异常，且未找到匹配的异常处理器。
				- 方法退出时，实质是让栈帧出栈。可能的操作有：1.将返回值压入上层调用栈帧 2.把异常信息抛给能够处理的栈帧 3.PC计数器指向方法调用的下一条指令
			- 在编译程序代码时，栈帧需要多大的局部变量表和多深的操作栈都是确定的，并且写入到方法表的Code属性之中，因此一个栈帧需要分配多大的内存在编译期就确定了。
		- 打印虚拟机栈信息：jstack -l pid
	- ***本地方法栈***：线程私有。为虚拟机执行Native方法服务。会出现StackOverFlowError和OutOfMemoryError异常
	- ***元空间***：线程共享。jdk1.8将方法区更改为方法区。用于存放类元信息、静态成员变量、常量、编译后代码等数据。堆外区域。会出现OurOfMemoryErroe异常。class文件中，除了类版本、字段、方法、接口等描述信息外，还有常量池，存放的是编译期生成的字面量和符号引用。
		- 运行时常量池：类加载之后存放类常量池的内容，并且将部分符号引用解析为直接引用进行保存。运行时也会有新的常量加入该常量池。
		- String常量池：已经被移入到堆中。需要了解String.intern()方法
	- ***堆***：线程共享。运行时数据区域中占空间最大的区域，几乎所有的对象都存放在堆中。垃圾回收的主要区域。会出现OutOfMemoryError异常。可通过参数-Xms和-Xmx控制堆的大小。默认最小为机器内存的1/64，最大为1/4
		- 新生代：新创建的实例对象会存放到新生代，当对象经历内存回收的次数达到一定值，会迁移到老年代。新生代的对象大部分会很快被回收掉。细分为Eden，From Survivor，To Survivor。
		- 老年代：进入老年代的对象一般比较稳定。
		- 新生代和老年代的比例默认为1:2。可通过-XX:NewRatio来指定。Eden:From:TO=8:1:1，可通过-XX:SurvivorRatio来设定
- **句柄和直接指针**：执行引擎通过引用访问对象的时候，有两种方式。
	- 通过句柄进行访问，在堆中建立一个句柄池，在句柄中存储着对应实例在堆中的位置，引用存储的是句柄的位置。
	- 通过直接指针访问，引用存储的是堆中实例的地址。
	- 句柄访问需要先找到句柄，然后才能找到实例，相对于直接指针访问会慢一些。但是句柄访问的好处在于垃圾回收的时候，只需要改变句柄中实例的位置。在HotSpot虚拟机实现中，采用的是直接指针的方式。
- **符号引用、直接引用、解析**：
	- ***符号引用***：以一组符号来描述所引用的目标，符号可以使任何形式的字面量，只要使用时能无歧义的定位到目标即可。符号引用的字面量形式存在于编译后的class文件中。
	- ***直接引用***：由符号引用在加载时解析为直接引用。可以是直接指向目标的指针、句柄、相对偏移量
	- ***解析***：所有方法调用中的目标方法在class文件中都是一个常量池的符号引用。满足“编译器可知，运行期不变”的方法，将在类加载的解析阶段由符号引用转化为直接引用，并记录在运行期常量池中，这类方法主要包括构造方法、私有方法、静态方法、父类方法，它们不可能被覆盖或者重写为其他版本。
- **静态分派、动态分派**：确定方法分派调用过程。编译器选择静态分派目标（重载方法），运行期选择动态分派目标（重写）
- **对象的内存布局**：对象头、实例数据、对齐填充
	- ***对象头***：包含两部分。1.存储对象运行时数据 2.类型指针，如果对象是数组的话，还包含数组的长度（4byte）
		- 存储运行时数据：Hash码、GC分代年龄、锁状态标识、线程持有的锁、偏向线程ID、偏向时间戳等。32位jvm下占4byte，64位jvm下占8byte。
		- 类型指针：指向类元数据的指针。32位jvm下占4byte。64位jvm下占8byte，如果开启指针压缩（默认开启），占4byte
	- ***实例数据***：对象真正存储的有效信息
	- ***对齐填充***：jvm规定对象的大小必须是8的倍数，若不足，则填充
	- ***详细参考***：[对象的内存布局](../basic/jvm/对象的内存布局.md)
- **类加载机制**：加载、连接（验证、准备、解析）、初始化
	- ***加载***：
	- ***验证***：
	- ***准备***：
	- ***解析***：
	- ***初始化***：
- **对象的实例化**：
- **cinit、init**：
- **JMM**：Java Memory Model。Java内存模型。由JVM规范中定义，用来屏蔽掉各种硬件及操作系统的内存访问的差异，以实现Java程序在各种平台下都能达到一致的并发效果。