ioc aop
动态代理
synchronized
volatile
运行时区域
类加载
reentrantlock
aqs
rocketmq、kafka
双亲委派机制



- synchronized：jdk提供的可重入、非公平的同步阻塞原语，可以用来修饰方法和代码块。jvm会为每一个关联了synchronized的对象关联一个monitor监视器，当字节码执行器遇到monitorenter指令，或者调用方法时，方法的flags中包含ACC_SYNCHRONIZED，当前线程会先获取同步锁，然后在执行同步方法/代码块中的逻辑，如果获取失败，会在锁队列（entry_list）中等待。
	- 在jdk1.6，对synchronized进行了优化，提供了锁从偏向锁-轻量级锁-重量级锁的升级过程。
	- 首先线程A尝试获取锁，在mark word中设置当前线程id。当线程B获取锁时，如果线程A存活，并且占有着锁，将锁升级为轻量级锁，否则尝试cas设置mark word中的threadid指向自己，设置失败，也会将锁升级为轻量级锁。
	- B将锁升级为轻量级锁时，会等待安全点（没有字节码在执行），先暂停持有偏向锁的A线程，将锁升级为轻量级锁，标志位设置为00，并唤醒A线程，将mark word设置为指向栈中锁记录的指针，而mark word原本存有的hashCode和gc等信息会存放在栈中，此后B线程尝试自旋获取锁，如果获取超时或者在获取的过程中，有其它线程也在尝试获取锁，则会将锁升级为重量级锁，标志位设置为10。
	- 锁升级为重量级锁之后，获取锁失败的线程会并入ObjectMonitor监控器的entryList中阻塞，当持有锁的线程释放锁之后，entryList和waitset中被唤醒的线程都会竞争锁。
	- 锁粗化：将临近的同步代码块合并为一个，避免多次获取锁
	- 锁消除：JIT编译
	- 偏向锁用于几乎没有锁竞争的情况下，每次都是同一个线程获取锁。轻量级锁用于参与锁竞争的线程不多，并且同步逻辑执行快，其他线程可以通过自旋很快获取锁的情况下。




- AOP：Spring的AOP依靠动态代理技术实现，为应用程序提供功能拓展、将固定模式的代码从业务中剥离出来单独维护。AOP为我们提供了在切入点的before/afterReturning/around/afterThrowable/after的增强。
	- AOP代理模式有两种，默认使用java动态代理（基于接口），cglib基于继承
	- AOP最常见的就是Spring事务模块提供的@Transactional注解为添加了该注解的方法提供事务的创建、提交、回滚的功能。
	- 常用的还有日志记录、性能监控等
- 动态代理和静态代理：对某个对象进行包装，以控制这个对象的访问（方法增强）。代理类需要和resource类有共同的父类接口。
	- 静态代理在编译的时候就确定了代理类。动态代理是在运行过程中生成代理类的。静态代理一般只能代理一个类，而动态代理可以代理多个实现了接口的类。

- jdk动态代理和cglib的区别：jdk动态代理只能代理实现了接口的类，通过反射机制生成实现该接口的类，通过调用被代理类的方法进行增强。而cglib是生成一个代理子类，覆盖其中的方法进行增强（因为采用了继承，所以该类和方法不要采用final修饰），底层使用asm进行字节码的生成。







- 线程的状态及变化过程
	- 线程的状态有初始、运行、阻塞、等待、超时等待、终止六种状态，其中运行可以细分为就绪和运行中
	- 线程实例化之后状态为初始；调用start()方法状态为运行；获取同步锁失败，进入阻塞状态；在阻塞状态被唤醒获取到锁，进入运行状态；运行中调用Thread.join()/Object.wait()/LockSupport.park()进入等待状态；在运行中调用Thread.sleep(long)/Object.wait(long)/Thread.join(long)/LockSupport.parkNanos()/LockSupport.parkUtil()进去超时等待状态；在等待/超时等待状态调用LockSupport.unpark()/Object.notify()/Object.notifyAll()进入运行状态；线程执行完成进去终止状态。
	
- JVM：类加载器、执行引擎、运行时区域、垃圾回收器、本地方法接口。
- 运行时区域包括：堆、虚拟机栈、本地方法栈、方法区（元空间）、程序计数器。
	- 程序中实例化的对象基本都是放到堆中
	- 虚拟机栈存储的是Java方法运行时数据
	- 方法区存储的是类元数据、静态变量、常量、编译后的代码
	- 程序计数器是线程私有，存储的是线程执行字节码的行号，用于线程恢复后能恢复正确执行的位置。


	
- AQS是一种提供了原子式状态管理、阻塞/唤醒线程以及队列模型的框架。



- volatile：可见性和一定程度的有序性
	- 对一个volatile的读，总是能看到任意线程对这个变量最后的写入
	- 确保指令重排序时，保证当程序执行到volatile变量的读/写时，在其前面的操作已经全部运行，在其后面的操作都没有运行。
	- volatile变量在汇编语言中，相对于没有volatile的变量多了lock的前缀，也叫内存屏障。
	- 重排序是虚拟机为了优化执行速度进行的优化，但是会保证优化后的程序与优化前的程序在单线程的环境下执行的结果一致。






- tcp和udp：tcp数据传输协议，面向连接，基于字节流的传输层协议，支持失败重传和有序。udp用户数据报协议，无需建立连接，发送数据报，不可靠，不保证有序。






- 三次握手：1.客户端向服务端发送SYN+序号A，2.服务端收到SYN后回复SYN（序号B）+ACK(A+1)，3.客户端向服务端发送ACK（B+1），服务端收到该ack之后，连接正式建立
- 四次挥手：
	- A关闭向B的发送通道：
		- A发送FIN码（序号K），并且发送一个ACK，对B最后一次发送数据的确认
		- B返回ACK（序号K+1）
	- B关闭向A的发送通道：（收到A关闭的请求后，不一定关闭B向A发送的通道）
		- B发送FIN码（序号X）
		- A向B发送ACK（序号X+1）
- 原因：三次握手完之后，服务端和客户端都需要知道对方的发送和接收功能是完好的，第一次服务端知道客户端可以发送消息，第二次客户端知道服务端可以接收和发送消息，第三次，服务端知道客户端可以接收消息。  
 	   四次挥手，因为tcp连接是全双工的，客户端和服务端都可以发送和接收消息。

-  Spring Cloud 和 Dubbo：spring cloud是一套微服务的解决方案，由一系列组件提供功能支持。而dubbo是一个分布式的服务治理框架。
	-  两者最大的区别在于服务调用方面，dubbo采用的是RPC的方式调用，提供了多种基于长连接的NIO框架的封装，以及Hessian2等序列化方式，服务调用的性能较Spring Cloud的Http Rest方式高，但是dubbo服务提供方和调用方接口依赖方式太强，项目大的话，服务间的依赖管理会很麻烦，而Http Rest不会出现这种问题，只需要将接口维护到类似swagger上面就可以。
	-  cloud生态圈的组件完善，dubbo只是为我们提供了服务治理，如果需要使用配置中心等组件，需要整合，毕竟不是和dubbo无缝连接的组件，整合的话风险高一些。
	-  dubbo在国内用户人群广，文档多，而cloud文档相对较少，而且开发项目需要引入的组件较多，学习成本高。


- dubbo原理：

- 容错模式（cluster）：失败重试、快速失败、失败记录、失败定时重试、forking（并行调用，只要有一个成功就算成功）、广播调用（一个失败就算失败）
- 负载：随机（默认）、轮询、最少活跃调用数、一致性哈希（带有相同参数的请求总是被发给同一个提供者）






- Junit注解：




- ThreadLocal：



- spring注解如何生效、类是如何扫描的



- Dubbo原理、kafka原理
	- 经验证，顺序写磁盘效率比随机写内存还要高，这是Kafka高吞吐率的一个很重要的保证
	- 上面一节还涉及到一个概念，即HW。HW俗称高水位，HighWatermark的缩写，取一个partition对应的ISR中最小的LEO作为HW，consumer最多只能消费到HW所在的位置。另外每个replica都有HW,leader和follower各自负责更新自己的HW的状态。对于leader新写入的消息，consumer不能立刻消费，leader会等待该消息被所有ISR中的replicas同步后更新HW，此时消息才能被consumer消费。这样就保证了如果leader所在的broker失效，该消息仍然可以从新选举的leader中获取。对于来自内部broker的读取请求，没有HW的限制。
	- 数据可靠性和持久性保证 request.required.acks min.insync.replicas
	- HW
	- ISR宕机顺序影响恢复


- 分布式事务


- 栈的原理和应用：左右括号是否正确匹配的经典问题




- 双亲委派机制：除了顶层的启动类加载器，其它每个加载器都应该有自己的父类加载器。当进行类加载时，首先把加载请求委派给父加载器完成，只有当父类加载器反馈无法完成加载时，自己才会尝试加载。