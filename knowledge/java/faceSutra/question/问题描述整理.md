ioc aop
动态代理
synchronized
volatile
运行时区域
类加载
reentrantlock
aqs
rocketmq、kafka
双亲委派机制



- synchronized：jdk提供的可重入、非公平的同步阻塞原语，可以用来修饰方法和代码块。jvm会为每一个关联了synchronized的对象关联一个monitor监视器，当字节码执行器遇到monitorenter指令，或者调用方法时，方法的flags中包含ACC_SYNCHRONIZED，当前线程会先获取同步锁，然后在执行同步方法/代码块中的逻辑，如果获取失败，会在锁队列（entry_list）中等待。
	- 在jdk1.6，对synchronized进行了优化，提供了锁从偏向锁-轻量级锁-重量级锁的升级过程。
	- 首先线程A尝试获取锁，在mark word中设置当前线程id。当线程B获取锁时，如果线程A存活，并且占有着锁，将锁升级为轻量级锁，否则尝试cas设置mark word中的threadid指向自己，设置失败，也会将锁升级为轻量级锁。
	- B将锁升级为轻量级锁时，会等待安全点（没有字节码在执行），先暂停持有偏向锁的A线程，将锁升级为轻量级锁，标志位设置为00，并唤醒A线程，将mark word设置为指向栈中锁记录的指针，而mark word原本存有的hashCode和gc等信息会存放在栈中，此后B线程尝试自旋获取锁，如果获取超时或者在获取的过程中，有其它线程也在尝试获取锁，则会将锁升级为重量级锁，标志位设置为10。
	- 锁升级为重量级锁之后，获取锁失败的线程会并入ObjectMonitor监控器的entryList中阻塞，当持有锁的线程释放锁之后，entryList和waitset中被唤醒的线程都会竞争锁。
	- 锁粗化：将临近的同步代码块合并为一个，避免多次获取锁
	- 锁消除：JIT编译




- AOP：Spring的AOP依靠动态代理技术实现，为应用程序提供功能拓展、将固定模式的代码从业务中剥离出来单独维护。AOP为我们提供了在切入点的before/afterReturning/around/afterThrowable/after的增强。
	- AOP代理模式有两种，默认使用java动态代理（基于接口），cglib基于继承
	- AOP最常见的就是Spring事务模块提供的@Transactional注解为添加了该注解的方法提供事务的创建、提交、回滚的功能。
	- 常用的还有日志记录、性能监控等
- 动态代理和静态代理：对某个对象进行包装，以控制这个对象的访问（方法增强）。代理类需要和resource类有共同的父类接口。
	- 静态代理在编译的时候就确定了代理类。动态代理是在运行过程中生成代理类的
- 双亲委派机制：

010 85535593

